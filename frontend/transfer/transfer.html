<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bank Transfer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="../pgcss.css"/>
  <style>
    .form-container { max-width: 720px; margin: 24px auto; }
    .log-box { border: 1px solid #e5e5e5; border-radius: 6px; padding: 12px; min-height: 160px; }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-light bg-light px-4">
    <span class="navbar-brand mb-0 h1">Quantum Secure Payment Gateway</span>
    <a href="/dashboard" class="btn btn-outline-primary">Back to Dashboard</a>
  </nav>

  <!-- Transfer Page -->
  <div class="form-container" id="transferPage">
    <h3 class="text-center">Transfer Money</h3>
    <form id="transferForm">
      <div class="mb-3">
        <label for="receiver" class="form-label">Select Friend</label>
        <select class="form-select" id="receiver" required>
          <option value="" selected disabled>Loading...</option>
        </select>
      </div>
      <div class="mb-3">
        <label for="amount" class="form-label">Amount (₹)</label>
        <input type="number" min="1" class="form-control" id="amount" placeholder="Enter amount" required>
      </div>
      <button type="submit" class="btn btn-primary w-100">Send</button>
    </form>

    <h5 class="mt-4">Transaction Log</h5>
    <div class="log-box" id="logBox"></div>
  </div>

  <script>
  // --- Setup and helpers ---

  // We now fetch policies from Raspberry Pi through server.js proxy
  const POLICIES_API = "/api/policies-csv";

  const senderCache = { name: "You", bank: "Sender Bank", ready: false };

  function getEl(id) { return document.getElementById(id); }
  function logBox() { return getEl("logBox"); }
  function clearLog() { logBox().innerHTML = ""; }
  function print(line) {
    const p = document.createElement("p");
    p.className = "mb-1";
    p.textContent = line;
    logBox().appendChild(p);
    logBox().scrollTop = logBox().scrollHeight;
  }

  function norm(x) { return String(x || "").trim().toLowerCase(); }

  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    const header = lines.shift().split(",");
    return lines.map(line => {
      const cols = line.split(",");
      const obj = {};
      header.forEach((h, i) => obj[h.trim()] = cols[i] ? cols[i].trim() : "");
      return obj;
    });
  }

  async function loadPolicies() {
    const res = await fetch(POLICIES_API);
    if (!res.ok) throw new Error("Failed to load policies.csv");
    return parseCSV(await res.text());
  }

  function matchRow(rows, fromBank, toBank) {
    const f = norm(fromBank), t = norm(toBank);
    
    // Exact direction
    let r = rows.find(x => norm(x["From_Bank"]) === f && norm(x["To_Bank"]) === t);
    if (r) return r;

    // Reverse direction fallback (important!)
    r = rows.find(x => norm(x["From_Bank"]) === t && norm(x["To_Bank"]) === f);
    return r || null;
  }

  function detectMode(row) {
    const algo = (row["Policy_SW_Algo"] || "").toLowerCase();

    if (algo.includes("hybrid")) return "Hybrid";
    if (
        algo.includes("kyber") ||
        algo.includes("ml-kem") ||
        algo.includes("falcon") ||
        algo.includes("dilithium")
    ) return "PQC";
    return "Classical";
  }


  function flowByMode(modeKey) {
    if (modeKey === "Hybrid") {
      return {
        mode: "Hybrid (Classical + PQC)",
        tls: "TLS 1.3 Hybrid Key Exchange (ECDH + Kyber)",
        kx: "ECDH + ML-KEM negotiation",
        jwt: "JWT signed with dual classical + PQC signature",
        cert: "Hybrid X.509 cert validated",
        perfNote: "Time: ~180 ms | Secure at quantum scale"
      };
    } else if (modeKey === "PQC") {
      return {
        mode: "PQC-Only",
        tls: "TLS-PQTLS (Kyber-based KEM)",
        kx: "Kyber ML-KEM performed",
        jwt: "JWT signed with ML-DSA",
        cert: "Dilithium-based cert verified",
        perfNote: "Time: ~260 ms | Max quantum-resistance"
      };
    } else {
      return {
        mode: "Classical-Only",
        tls: "TLS 1.3 ECDH Key Exchange",
        kx: "Ephemeral ECDH performed",
        jwt: "Standard HS256 JWT",
        cert: "RSA X.509 cert verified",
        perfNote: "Time: ~50 ms | Legacy security"
      };
    }
  }

  // --- API Calls ---

  async function fetchSender() {
    const r = await fetch("/api/me");
    if (r.status === 401) location.href = "/";
    const me = await r.json();
    senderCache.name = me.name || "You";
    senderCache.bank = me.bank || "Sender Bank";
    senderCache.ready = true;
  }

  async function loadFriends() {
    const sel = getEl("receiver");
    const r = await fetch("/api/users");
    if (r.status === 401) { location.href="/"; return; }
    const users = await r.json();
    sel.innerHTML = "";
    users.forEach(u => {
      const opt = document.createElement("option");
      opt.value = u.id;
      opt.textContent = `${u.name} (${u.bank}, @${u.username})`;
      opt.dataset.bank = u.bank;
      sel.appendChild(opt);
    });
  }

  async function persistLog({ timestamp, senderName, receiverName, amount, mode, steps }) {
    await fetch("/api/log-csv", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        timestamp,
        senderName,
        receiverName,
        amount,
        mode,
        steps: steps.join(" || ") // store steps in one cell, separated by ||
      })
    });
  }

  async function createTransfer(receiverId, amount) {
    const r = await fetch("/api/transfer", {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify({ receiverId, amount })
    });
    if (!r.ok) throw new Error(await r.text());
  }

  // ---- MAIN FLOW ----

  async function runFlow(amount) {
    clearLog();

    const sBank = senderCache.bank;
    const sel = getEl("receiver");
    const rBank = sel.options[sel.selectedIndex].dataset.bank;

    print("Starting secure transaction flow...");

    let modeKey = "Classical";
    try {
      const rows = await loadPolicies();
      const rule = matchRow(rows, sBank, rBank);
      if (rule) modeKey = detectMode(rule);
      else print(`No policy rule found for ${sBank} → ${rBank}, defaulting to Classical.`);
    } catch {
      print("Policies unavailable. Defaulting to Classical.");
    }

    const f = flowByMode(modeKey);
    print(`Negotiating security mode: ${f.mode}`);
    print(f.tls);
    print(f.kx);
    print(f.jwt);
    print(f.cert);
    print(`Transfer encrypted and transmitted. Mode=${f.mode}`);
    print(f.perfNote);

    await persistLog({
    timestamp: new Date().toISOString(),
    senderName: sName,
    receiverName: rDetails,
    amount: Number(amount),
    mode: f.mode,
    steps
  });
  }

  document.addEventListener("DOMContentLoaded", async () => {
    await fetchSender();
    await loadFriends();

    getEl("transferForm").addEventListener("submit", async e => {
      e.preventDefault();
      const receiverId = getEl("receiver").value;
      const amount = Number(getEl("amount").value);
      await createTransfer(receiverId, amount);
      await runFlow(amount);
      e.target.reset();
    });
  });
</script>

</body>
</html>
