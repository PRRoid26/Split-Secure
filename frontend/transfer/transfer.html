<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bank Transfer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="../pgcss.css"/>
  <style>
    .form-container { max-width: 720px; margin: 24px auto; }
    .log-box { border: 1px solid #e5e5e5; border-radius: 6px; padding: 12px; min-height: 160px; }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-light bg-light px-4">
    <span class="navbar-brand mb-0 h1">Quantum Secure Payment Gateway</span>
    <a href="/dashboard" class="btn btn-outline-primary">Back to Dashboard</a>
  </nav>

  <!-- Transfer Page -->
  <div class="form-container" id="transferPage">
    <h3 class="text-center">Transfer Money</h3>
    <form id="transferForm">
      <div class="mb-3">
        <label for="receiver" class="form-label">Select Friend</label>
        <select class="form-select" id="receiver" required>
          <option value="" selected disabled>Loading...</option>
        </select>
      </div>
      <div class="mb-3">
        <label for="amount" class="form-label">Amount (₹)</label>
        <input type="number" min="1" class="form-control" id="amount" placeholder="Enter amount" required>
      </div>
      <button type="submit" class="btn btn-primary w-100">Send</button>
    </form>

    <h5 class="mt-4">Transaction Log</h5>
    <div class="log-box" id="logBox"></div>
  </div>

  <script>
    // --- Setup and helpers ---
    const CSV_PATH = "./bank_testcases.csv"; // put CSV next to this HTML, or adjust path

    const senderCache = { name: "You", bank: "Sender Bank", ready: false };

    function getEl(id) { return document.getElementById(id); }
    function logBox() { return getEl("logBox"); }
    function clearLog() { const box = logBox(); if (box) box.innerHTML = ""; }
    function print(line) {
      const box = logBox();
      if (!box) return;
      const p = document.createElement("p");
      p.className = "mb-1";
      p.textContent = line;
      box.appendChild(p);
      box.scrollTop = box.scrollHeight;
    }

    function norm(x) { return String(x || "").trim().toLowerCase(); }

    function parseCSV(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      if (!lines.length) return [];
      const header = lines[0].split(",").map(h => h.trim());
      const rows = [];
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(",").map(c => c.trim());
        if (cols.length !== header.length) continue;
        const obj = {};
        header.forEach((h, idx) => (obj[h] = cols[idx]));
        rows.push(obj);
      }
      return rows;
    }

    async function loadTestcases() {
      const res = await fetch(CSV_PATH, { credentials: "same-origin" });
      if (!res.ok) throw new Error("Failed to load bank_testcases.csv");
      return parseCSV(await res.text());
    }

    function matchRow(rows, fromBank, toBank) {
      const f = norm(fromBank), t = norm(toBank);
      let r = rows.find(x => norm(x["From Bank"]) === f && norm(x["To Bank"]) === t);
      if (r) return r;
      r = rows.find(x => norm(x["From Bank"]) === t && norm(x["To Bank"]) === f);
      return r || null;
    }

    function detectMode(row) {
      const base = (row["HW_Base"] || "").toLowerCase();
      const budget = (row["HW_Budget"] || "").toLowerCase();
      const algo = (row["Receiver Algo"] || row["Receiver_Algo"] || "").toLowerCase();

      const hasPQC = base.includes("pqc") || budget.includes("pqc") ||
                     algo.includes("pqc") || algo.includes("kyber") ||
                     algo.includes("ml-dsa") || algo.includes("dilithium");

      const hasClassical = base.includes("classical") || budget.includes("classical") ||
                           algo.includes("ecd") || algo.includes("rsa") ||
                           algo.includes("hs256");

      if (hasPQC && hasClassical) return "Hybrid";
      if (hasPQC) return "PQC";
      return "Classical";
    }

    function flowByMode(modeKey) {
      if (modeKey === "Hybrid") {
        return {
          mode: "Hybrid (Classical + PQC)",
          tls: "TLS 1.3 (Hybrid: ECDH + Kyber)",
          kx: "Ephemeral ECDH + Kyber key exchange performed.",
          jwt: "JWT signed with HS256 + PQC signature (ML-DSA).",
          cert: "Hybrid X.509 cert with RSA + PQC (Dilithium) validated.",
          perfNote: "Time: ~150 ms | CPU usage: Medium"
        };
      } else if (modeKey === "PQC") {
        return {
          mode: "PQC",
          tls: "TLS 1.3 (PQC only: Kyber)",
          kx: "Kyber key exchange performed.",
          jwt: "JWT signed with PQC signature (ML-DSA).",
          cert: "PQC-only X.509 cert (Dilithium) validated.",
          perfNote: "Time: ~250 ms | CPU usage: High"
        };
      } else {
        return {
          mode: "Classical-only",
          tls: "TLS 1.3 (Classical: ECDH)",
          kx: "Ephemeral ECDH key exchange performed.",
          jwt: "JWT signed with HS256.",
          cert: "Classical RSA X.509 cert validated.",
          perfNote: "Time: ~50 ms | CPU usage: Low"
        };
      }
    }

    // --- Data from server ---

    async function fetchSender() {
      try {
        const res = await fetch("/api/me", {
          method: "GET",
          credentials: "same-origin",
          headers: { Accept: "application/json" }
        });
        if (res.status === 401) {
          window.location.href = "/";
          return;
        }
        if (res.ok) {
          const me = await res.json();
          senderCache.name = me.name || "You";
          senderCache.bank = me.bank || "Sender Bank";
        }
      } catch {
        // keep defaults
      } finally {
        senderCache.ready = true;
      }
    }

    async function loadFriends() {
      const select = document.getElementById("receiver");
      try {
        const res = await fetch("/api/users", {
          method: "GET",
          credentials: "same-origin",
          headers: { Accept: "application/json" }
        });
        if (res.status === 401) { window.location.href = "/"; return; }
        if (!res.ok) throw new Error("Failed to load users");
        const users = await res.json();
        select.innerHTML = "";
        if (!Array.isArray(users) || users.length === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.disabled = true;
          opt.selected = true;
          opt.textContent = "No users available";
          select.appendChild(opt);
          return;
        }
        users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = String(u.id);
          opt.textContent = `${u.name} (${u.bank || "Bank N/A"}, @${u.username})`;
          opt.dataset.username = u.username || "";
          opt.dataset.bank = u.bank || "";
          opt.dataset.account = u.account || "";
          opt.dataset.phone = u.phone || "";
          select.appendChild(opt);
        });
      } catch (e) {
        console.error(e);
        select.innerHTML = "";
        const opt = document.createElement("option");
        opt.value = "";
        opt.disabled = true;
        opt.selected = true;
        opt.textContent = "Error loading users";
        select.appendChild(opt);
      }
    }

    async function persistLog(payload) {
      try {
        const res = await fetch("/api/transfer-log", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "same-origin",
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          console.warn("Log save failed:", await res.text());
        }
      } catch (e) {
        console.warn("Log save error:", e);
      }
    }

    async function createTransfer(receiverId, amount, channel = "UPI") {
      const res = await fetch("/api/transfer", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "same-origin",
        body: JSON.stringify({ receiverId, amount: Number(amount), channel })
      });
      if (!res.ok) throw new Error(await res.text());
      return res.json();
    }

    // --- Security flow ---

    function currentSender() {
      return { sName: senderCache.name, sBank: senderCache.bank };
    }

    function currentReceiver() {
      const sel = getEl("receiver");
      const opt = sel?.options[sel.selectedIndex];
      const bank = (opt?.dataset.bank || "Receiver Bank").trim();
      const uname = (opt?.dataset.username || "").trim();
      const label = (opt?.textContent || "Receiver").trim();
      const rDetails = uname ? `${label} (@${uname})` : label;
      return { rDetails, rBank: bank };
    }

    async function runFlow(amount) {
      clearLog();

      const { sName, sBank } = currentSender();
      const { rDetails, rBank } = currentReceiver();

      const steps = [];
      const step = s => { steps.push(s); print(s); };

      step("Starting secure transaction flow...");

      let modeKey = "Classical";
      try {
        const rows = await loadTestcases();
        const row = matchRow(rows, sBank, rBank);
        if (row) {
          modeKey = detectMode(row);
        } else {
          step(`Note: No CSV rule for ${sBank} → ${rBank}; using default mode.`);
        }
      } catch (e) {
        step("Note: Could not load bank_testcases.csv; using default mode.");
      }

      const f = flowByMode(modeKey);

      step(`Negotiating security mode with ${rDetails} : ${f.mode}`);
      step(`Initiating ${f.tls} handshake...`);
      step(f.kx);
      step("TLS handshake complete, secure channel established.");
      step("Generating JWT...");
      step(f.jwt);
      step("JWT issued and verified successfully.");
      step("Generating digital certificate...");
      step(f.cert);
      step(`Initiating transfer: ${sName} (${sBank}) → ${rDetails} (${rBank}), Amount: ₹${Number(amount).toLocaleString("en-IN")}...`);
      step("Encrypting transaction payload...");
      step("Transaction encrypted and transmitted.");
      step("Transfer complete successfully!");
      step(`Performance stats: ${f.perfNote}`);

      // Persist to server as JSON (log copy)
      const payload = {
        timestamp: new Date().toISOString(),
        senderName: sName,
        senderBank: sBank,
        receiverLabel: rDetails,
        receiverBank: rBank,
        amount: Number(amount),
        mode: f.mode,
        steps
      };
      await persistLog(payload);
    }

    // --- Init and submit ---

    document.addEventListener("DOMContentLoaded", () => {
      loadFriends();
      fetchSender();

      const form = getEl("transferForm");
      if (!form) return;

      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        // ensure sender profile loaded (best-effort)
        if (!senderCache.ready) await fetchSender();

        const sel = getEl("receiver");
        const amount = getEl("amount")?.value.trim();

        if (!sel?.value) { alert("Please select a friend."); return; }
        if (!amount || Number(amount) <= 0) { alert("Enter a valid amount."); return; }

        try {
          // 1) Create transaction in DB (broadcasts via SSE to dashboards)
          await createTransfer(Number(sel.value), Number(amount), "UPI");
          // 2) Render the security flow log to the UI and persist JSON log file
          await runFlow(amount);
          form.reset();
        } catch (err) {
          console.error(err);
          alert("Transfer failed. Please try again.");
        }
      });
    });
  </script>
</body>
</html>
